<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cds: cds::container::WeakRingBuffer&lt; T, Traits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1container_1_1_weak_ring_buffer.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">cds::container::WeakRingBuffer&lt; T, Traits &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__cds__nonintrusive__containers.html">Non-intrusive containers</a> &raquo; <a class="el" href="group__cds__nonintrusive__queue.html">Queue</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Single-producer single-consumer ring buffer.  
 <a href="classcds_1_1container_1_1_weak_ring_buffer.html#details">More...</a></p>

<p><code>#include &lt;cds/container/weak_ringbuffer.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cds::container::WeakRingBuffer&lt; T, Traits &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcds_1_1container_1_1_weak_ring_buffer.png" usemap="#cds::container::WeakRingBuffer_3C_20T_2C_20Traits_20_3E_map" alt=""/>
  <map id="cds::container::WeakRingBuffer_3C_20T_2C_20Traits_20_3E_map" name="cds::container::WeakRingBuffer_3C_20T_2C_20Traits_20_3E_map">
<area href="structcds_1_1bounded__container.html" title="Bounded container. " alt="cds::bounded_container" shape="rect" coords="0,0,259,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcds_1_1container_1_1_weak_ring_buffer_1_1rebind.html">rebind</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind template arguments.  <a href="structcds_1_1container_1_1_weak_ring_buffer_1_1rebind.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af1167c5484a24b46471b3fd9cb162b69"><td class="memItemLeft" align="right" valign="top"><a id="af1167c5484a24b46471b3fd9cb162b69"></a>
typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#af1167c5484a24b46471b3fd9cb162b69">value_type</a></td></tr>
<tr class="memdesc:af1167c5484a24b46471b3fd9cb162b69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type to be stored in the ring buffer. <br /></td></tr>
<tr class="separator:af1167c5484a24b46471b3fd9cb162b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d5b6bdd67cd22251dae16f354a894b"><td class="memItemLeft" align="right" valign="top"><a id="ad8d5b6bdd67cd22251dae16f354a894b"></a>
typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#ad8d5b6bdd67cd22251dae16f354a894b">traits</a></td></tr>
<tr class="memdesc:ad8d5b6bdd67cd22251dae16f354a894b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ring buffer traits. <br /></td></tr>
<tr class="separator:ad8d5b6bdd67cd22251dae16f354a894b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12cfe4adcb06d43c6c5a763371e728c0"><td class="memItemLeft" align="right" valign="top"><a id="a12cfe4adcb06d43c6c5a763371e728c0"></a>
typedef traits::memory_model&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#a12cfe4adcb06d43c6c5a763371e728c0">memory_model</a></td></tr>
<tr class="memdesc:a12cfe4adcb06d43c6c5a763371e728c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory ordering. See <code><a class="el" href="structcds_1_1opt_1_1memory__model.html" title="[type-option] Option setter for C++ memory model ">cds::opt::memory_model</a></code> option. <br /></td></tr>
<tr class="separator:a12cfe4adcb06d43c6c5a763371e728c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3b5ef7affaa6b3647a864bde9b6805"><td class="memItemLeft" align="right" valign="top"><a id="a3d3b5ef7affaa6b3647a864bde9b6805"></a>
typedef traits::value_cleaner&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#a3d3b5ef7affaa6b3647a864bde9b6805">value_cleaner</a></td></tr>
<tr class="memdesc:a3d3b5ef7affaa6b3647a864bde9b6805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value cleaner, see <code><a class="el" href="structcds_1_1container_1_1weak__ringbuffer_1_1traits.html#a7407c26ce91a93b784451793d2939bea" title="A functor to clean item dequeued. ">weak_ringbuffer::traits::value_cleaner</a></code>. <br /></td></tr>
<tr class="separator:a3d3b5ef7affaa6b3647a864bde9b6805"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ade3f4829aa7bee40abd0e3b904de7253"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#ade3f4829aa7bee40abd0e3b904de7253">WeakRingBuffer</a> (size_t <a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#a8cfc17f95530b21aba8f9b6512f7cdc8">capacity</a>=0)</td></tr>
<tr class="memdesc:ade3f4829aa7bee40abd0e3b904de7253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the ring buffer of <code>capacity</code>.  <a href="#ade3f4829aa7bee40abd0e3b904de7253">More...</a><br /></td></tr>
<tr class="separator:ade3f4829aa7bee40abd0e3b904de7253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe07507f1981dfb4fa6608d697f2597"><td class="memItemLeft" align="right" valign="top"><a id="aebe07507f1981dfb4fa6608d697f2597"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#aebe07507f1981dfb4fa6608d697f2597">~WeakRingBuffer</a> ()</td></tr>
<tr class="memdesc:aebe07507f1981dfb4fa6608d697f2597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the ring buffer. <br /></td></tr>
<tr class="separator:aebe07507f1981dfb4fa6608d697f2597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5bd7aab55417b4b873f355ea1bca96"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename CopyFunc &gt; </td></tr>
<tr class="memitem:aad5bd7aab55417b4b873f355ea1bca96"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#aad5bd7aab55417b4b873f355ea1bca96">push</a> (Q *arr, size_t count, CopyFunc copy)</td></tr>
<tr class="memdesc:aad5bd7aab55417b4b873f355ea1bca96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Batch push - push array <code>arr</code> of size <code>count</code>.  <a href="#aad5bd7aab55417b4b873f355ea1bca96">More...</a><br /></td></tr>
<tr class="separator:aad5bd7aab55417b4b873f355ea1bca96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3a59efe4975038abed8fcd6a0e408e"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:aae3a59efe4975038abed8fcd6a0e408e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_constructible&lt; <a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#af1167c5484a24b46471b3fd9cb162b69">value_type</a>, Q &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#aae3a59efe4975038abed8fcd6a0e408e">push</a> (Q *arr, size_t count)</td></tr>
<tr class="memdesc:aae3a59efe4975038abed8fcd6a0e408e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Batch push - push array <code>arr</code> of size <code>count</code> with assignment as copy functor.  <a href="#aae3a59efe4975038abed8fcd6a0e408e">More...</a><br /></td></tr>
<tr class="separator:aae3a59efe4975038abed8fcd6a0e408e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09108fab7d8951ea6258786ad59f11c"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab09108fab7d8951ea6258786ad59f11c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_constructible&lt; <a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#af1167c5484a24b46471b3fd9cb162b69">value_type</a>, Args... &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#ab09108fab7d8951ea6258786ad59f11c">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab09108fab7d8951ea6258786ad59f11c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push one element created from <code>args</code>.  <a href="#ab09108fab7d8951ea6258786ad59f11c">More...</a><br /></td></tr>
<tr class="separator:ab09108fab7d8951ea6258786ad59f11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8cccf098ab10638a020645b1c2e08d"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:aac8cccf098ab10638a020645b1c2e08d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#aac8cccf098ab10638a020645b1c2e08d">enqueue_with</a> (Func f)</td></tr>
<tr class="memdesc:aac8cccf098ab10638a020645b1c2e08d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues data to the ring using a functor.  <a href="#aac8cccf098ab10638a020645b1c2e08d">More...</a><br /></td></tr>
<tr class="separator:aac8cccf098ab10638a020645b1c2e08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe6e8db6d610ff34ea049ff7d6aa1ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#a1fe6e8db6d610ff34ea049ff7d6aa1ae">enqueue</a> (<a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#af1167c5484a24b46471b3fd9cb162b69">value_type</a> const &amp;val)</td></tr>
<tr class="memdesc:a1fe6e8db6d610ff34ea049ff7d6aa1ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues <code>val</code> value into the queue.  <a href="#a1fe6e8db6d610ff34ea049ff7d6aa1ae">More...</a><br /></td></tr>
<tr class="separator:a1fe6e8db6d610ff34ea049ff7d6aa1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad133fc131ad51e681a520ce77938d1da"><td class="memItemLeft" align="right" valign="top"><a id="ad133fc131ad51e681a520ce77938d1da"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#ad133fc131ad51e681a520ce77938d1da">enqueue</a> (<a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#af1167c5484a24b46471b3fd9cb162b69">value_type</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:ad133fc131ad51e681a520ce77938d1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueues <code>val</code> value into the queue, move semantics. <br /></td></tr>
<tr class="separator:ad133fc131ad51e681a520ce77938d1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ebe914eb2b34bdc722a914d7a74d95"><td class="memItemLeft" align="right" valign="top"><a id="ab1ebe914eb2b34bdc722a914d7a74d95"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#ab1ebe914eb2b34bdc722a914d7a74d95">push</a> (<a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#af1167c5484a24b46471b3fd9cb162b69">value_type</a> const &amp;val)</td></tr>
<tr class="memdesc:ab1ebe914eb2b34bdc722a914d7a74d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <code><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#a1fe6e8db6d610ff34ea049ff7d6aa1ae" title="Enqueues val value into the queue. ">enqueue( value_type const&amp; )</a></code> <br /></td></tr>
<tr class="separator:ab1ebe914eb2b34bdc722a914d7a74d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfdb5467709087ed61b7f1989f8f97c"><td class="memItemLeft" align="right" valign="top"><a id="aebfdb5467709087ed61b7f1989f8f97c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#aebfdb5467709087ed61b7f1989f8f97c">push</a> (<a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#af1167c5484a24b46471b3fd9cb162b69">value_type</a> &amp;&amp;val)</td></tr>
<tr class="memdesc:aebfdb5467709087ed61b7f1989f8f97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <code><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#ad133fc131ad51e681a520ce77938d1da" title="Enqueues val value into the queue, move semantics. ">enqueue( value_type&amp;&amp; )</a></code> <br /></td></tr>
<tr class="separator:aebfdb5467709087ed61b7f1989f8f97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f22f387b3a057715929ef6dca28b05"><td class="memTemplParams" colspan="2"><a id="a26f22f387b3a057715929ef6dca28b05"></a>
template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a26f22f387b3a057715929ef6dca28b05"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#a26f22f387b3a057715929ef6dca28b05">push_with</a> (Func f)</td></tr>
<tr class="memdesc:a26f22f387b3a057715929ef6dca28b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <code><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#aac8cccf098ab10638a020645b1c2e08d" title="Enqueues data to the ring using a functor. ">enqueue_with()</a></code> <br /></td></tr>
<tr class="separator:a26f22f387b3a057715929ef6dca28b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13333a0c045795ff612f05f865a3b98b"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename CopyFunc &gt; </td></tr>
<tr class="memitem:a13333a0c045795ff612f05f865a3b98b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#a13333a0c045795ff612f05f865a3b98b">pop</a> (Q *arr, size_t count, CopyFunc copy)</td></tr>
<tr class="memdesc:a13333a0c045795ff612f05f865a3b98b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Batch pop <code>count</code> element from the ring buffer into <code>arr</code>.  <a href="#a13333a0c045795ff612f05f865a3b98b">More...</a><br /></td></tr>
<tr class="separator:a13333a0c045795ff612f05f865a3b98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d8ff8edfd188df6b14e4b1c59eda4e"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:ab0d8ff8edfd188df6b14e4b1c59eda4e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_assignable&lt; Q &amp;, <a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#af1167c5484a24b46471b3fd9cb162b69">value_type</a> const  &amp; &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#ab0d8ff8edfd188df6b14e4b1c59eda4e">pop</a> (Q *arr, size_t count)</td></tr>
<tr class="memdesc:ab0d8ff8edfd188df6b14e4b1c59eda4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Batch pop - push array <code>arr</code> of size <code>count</code> with assignment as copy functor.  <a href="#ab0d8ff8edfd188df6b14e4b1c59eda4e">More...</a><br /></td></tr>
<tr class="separator:ab0d8ff8edfd188df6b14e4b1c59eda4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3072be07622d1b88d7fe41ff261ebd0e"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a3072be07622d1b88d7fe41ff261ebd0e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_assignable&lt; Q &amp;, <a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#af1167c5484a24b46471b3fd9cb162b69">value_type</a> const  &amp; &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#a3072be07622d1b88d7fe41ff261ebd0e">dequeue</a> (Q &amp;val)</td></tr>
<tr class="memdesc:a3072be07622d1b88d7fe41ff261ebd0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeues an element from the ring to <code>val</code>.  <a href="#a3072be07622d1b88d7fe41ff261ebd0e">More...</a><br /></td></tr>
<tr class="separator:a3072be07622d1b88d7fe41ff261ebd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac00ab8bc16daaef122a2bf41a62d84"><td class="memTemplParams" colspan="2"><a id="a3ac00ab8bc16daaef122a2bf41a62d84"></a>
template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a3ac00ab8bc16daaef122a2bf41a62d84"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_assignable&lt; Q &amp;, <a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#af1167c5484a24b46471b3fd9cb162b69">value_type</a> const  &amp; &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#a3ac00ab8bc16daaef122a2bf41a62d84">pop</a> (Q &amp;val)</td></tr>
<tr class="memdesc:a3ac00ab8bc16daaef122a2bf41a62d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <code><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#a3072be07622d1b88d7fe41ff261ebd0e" title="Dequeues an element from the ring to val. ">dequeue( Q&amp; )</a></code> <br /></td></tr>
<tr class="separator:a3ac00ab8bc16daaef122a2bf41a62d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f1ba3ef5da174d07fbd3338271d1de"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a13f1ba3ef5da174d07fbd3338271d1de"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#a13f1ba3ef5da174d07fbd3338271d1de">dequeue_with</a> (Func f)</td></tr>
<tr class="memdesc:a13f1ba3ef5da174d07fbd3338271d1de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dequeues a value using a functor.  <a href="#a13f1ba3ef5da174d07fbd3338271d1de">More...</a><br /></td></tr>
<tr class="separator:a13f1ba3ef5da174d07fbd3338271d1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b441c26f1a1858f70dabb83cbbbdf9"><td class="memTemplParams" colspan="2"><a id="ab4b441c26f1a1858f70dabb83cbbbdf9"></a>
template&lt;typename Func &gt; </td></tr>
<tr class="memitem:ab4b441c26f1a1858f70dabb83cbbbdf9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#ab4b441c26f1a1858f70dabb83cbbbdf9">pop_with</a> (Func f)</td></tr>
<tr class="memdesc:ab4b441c26f1a1858f70dabb83cbbbdf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <code><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#a13f1ba3ef5da174d07fbd3338271d1de" title="Dequeues a value using a functor. ">dequeue_with()</a></code> <br /></td></tr>
<tr class="separator:ab4b441c26f1a1858f70dabb83cbbbdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea0702fa72b4ee723f9f78f56de1372"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#af1167c5484a24b46471b3fd9cb162b69">value_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#afea0702fa72b4ee723f9f78f56de1372">front</a> ()</td></tr>
<tr class="memdesc:afea0702fa72b4ee723f9f78f56de1372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets pointer to first element of ring buffer.  <a href="#afea0702fa72b4ee723f9f78f56de1372">More...</a><br /></td></tr>
<tr class="separator:afea0702fa72b4ee723f9f78f56de1372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a249b769ffc63a5936e9a3f48905ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#a90a249b769ffc63a5936e9a3f48905ab">pop_front</a> ()</td></tr>
<tr class="memdesc:a90a249b769ffc63a5936e9a3f48905ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes front element of ring-buffer.  <a href="#a90a249b769ffc63a5936e9a3f48905ab">More...</a><br /></td></tr>
<tr class="separator:a90a249b769ffc63a5936e9a3f48905ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c674dbe7cc5c2f0df00d32df35eeb9"><td class="memItemLeft" align="right" valign="top"><a id="aa1c674dbe7cc5c2f0df00d32df35eeb9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#aa1c674dbe7cc5c2f0df00d32df35eeb9">clear</a> ()</td></tr>
<tr class="memdesc:aa1c674dbe7cc5c2f0df00d32df35eeb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the ring buffer (only consumer can call this function!) <br /></td></tr>
<tr class="separator:aa1c674dbe7cc5c2f0df00d32df35eeb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae503f5c2aa7882394c3efefb2c0db524"><td class="memItemLeft" align="right" valign="top"><a id="ae503f5c2aa7882394c3efefb2c0db524"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#ae503f5c2aa7882394c3efefb2c0db524">empty</a> () const</td></tr>
<tr class="memdesc:ae503f5c2aa7882394c3efefb2c0db524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the ring-buffer is empty. <br /></td></tr>
<tr class="separator:ae503f5c2aa7882394c3efefb2c0db524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20111a03a75e933c5e7b4595c8593136"><td class="memItemLeft" align="right" valign="top"><a id="a20111a03a75e933c5e7b4595c8593136"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#a20111a03a75e933c5e7b4595c8593136">full</a> () const</td></tr>
<tr class="memdesc:a20111a03a75e933c5e7b4595c8593136"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the ring-buffer is full. <br /></td></tr>
<tr class="separator:a20111a03a75e933c5e7b4595c8593136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7478de455fded0e3a7ab8f65a9c70676"><td class="memItemLeft" align="right" valign="top"><a id="a7478de455fded0e3a7ab8f65a9c70676"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#a7478de455fded0e3a7ab8f65a9c70676">size</a> () const</td></tr>
<tr class="memdesc:a7478de455fded0e3a7ab8f65a9c70676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current size of ring buffer. <br /></td></tr>
<tr class="separator:a7478de455fded0e3a7ab8f65a9c70676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfc17f95530b21aba8f9b6512f7cdc8"><td class="memItemLeft" align="right" valign="top"><a id="a8cfc17f95530b21aba8f9b6512f7cdc8"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#a8cfc17f95530b21aba8f9b6512f7cdc8">capacity</a> () const</td></tr>
<tr class="memdesc:a8cfc17f95530b21aba8f9b6512f7cdc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns capacity of the ring buffer. <br /></td></tr>
<tr class="separator:a8cfc17f95530b21aba8f9b6512f7cdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Traits = weak_ringbuffer::traits&gt;<br />
class cds::container::WeakRingBuffer&lt; T, Traits &gt;</h3>

<p>Single-producer single-consumer ring buffer. </p>
<p>Source: [2013] Nhat Minh Le, Adrien Guatto, Albert Cohen, Antoniu Pop. Correct and Effcient Bounded FIFO Queues. [Research Report] RR-8365, INRIA. 2013. &lt;hal-00862450&gt;</p>
<p>Ring buffer is a bounded queue. Additionally, <code>WeakRingBuffer</code> supports batch operations - you can push/pop an array of elements.</p>
<p>There are a specialization <a class="el" href="classcds_1_1container_1_1_weak_ring_buffer_3_01void_00_01_traits_01_4.html#cds_nonintrusive_WeakRingBuffer_void">WeakRingBuffer&lt;void, Traits&gt;</a> that is not a queue but a "memory pool" between producer and consumer threads. <code>WeakRingBuffer&lt;void&gt;</code> supports variable-sized data.</p>
<dl class="section warning"><dt>Warning</dt><dd>: <code>WeakRingBuffer</code> is developed for 64-bit architecture. 32-bit platform must provide support for 64-bit atomics. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ade3f4829aa7bee40abd0e3b904de7253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3f4829aa7bee40abd0e3b904de7253">&#9670;&nbsp;</a></span>WeakRingBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = weak_ringbuffer::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html">cds::container::WeakRingBuffer</a>&lt; T, Traits &gt;::<a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html">WeakRingBuffer</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the ring buffer of <code>capacity</code>. </p>
<p>For <code><a class="el" href="classcds_1_1opt_1_1v_1_1uninitialized__static__buffer.html" title="Static uninitialized buffer. ">cds::opt::v::uninitialized_static_buffer</a></code> the <code>nCapacity</code> parameter is ignored.</p>
<p>If the buffer capacity is a power of two, lightweight binary arithmetics is used instead of modulo arithmetics. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3072be07622d1b88d7fe41ff261ebd0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3072be07622d1b88d7fe41ff261ebd0e">&#9670;&nbsp;</a></span>dequeue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = weak_ringbuffer::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_assignable&lt;Q&amp;, <a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#af1167c5484a24b46471b3fd9cb162b69">value_type</a> const&amp;&gt;::value, bool&gt;::type <a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html">cds::container::WeakRingBuffer</a>&lt; T, Traits &gt;::dequeue </td>
          <td>(</td>
          <td class="paramtype">Q &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dequeues an element from the ring to <code>val</code>. </p>
<p>The function is available only if <code>std::is_assignable&lt;Q&amp;, value_type const&amp;&gt;::value</code> is <code>true</code>.</p>
<p>Returns <code>false</code> if the ring is full or <code>true</code> otherwise. </p>

</div>
</div>
<a id="a13f1ba3ef5da174d07fbd3338271d1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f1ba3ef5da174d07fbd3338271d1de">&#9670;&nbsp;</a></span>dequeue_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = weak_ringbuffer::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html">cds::container::WeakRingBuffer</a>&lt; T, Traits &gt;::dequeue_with </td>
          <td>(</td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dequeues a value using a functor. </p>
<p><code>Func</code> is a functor called to copy dequeued value. The functor takes one argument - a reference to removed node: </p><div class="fragment"><div class="line"><a class="code" href="namespacecds.html">cds</a>:container::WeakRingBuffer&lt; Foo &gt; myRing;</div><div class="line">Bar bar;</div><div class="line">myRing.dequeue_with( [&amp;bar]( Foo&amp; src ) { bar = std::move( src );});</div></div><!-- fragment --><p>Returns <code>true</code> if the ring is not empty, <code>false</code> otherwise. The functor is called only if the ring is not empty. </p>

</div>
</div>
<a id="ab09108fab7d8951ea6258786ad59f11c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09108fab7d8951ea6258786ad59f11c">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = weak_ringbuffer::traits&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_constructible&lt;<a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#af1167c5484a24b46471b3fd9cb162b69">value_type</a>, Args...&gt;::value, bool&gt;::type <a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html">cds::container::WeakRingBuffer</a>&lt; T, Traits &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push one element created from <code>args</code>. </p>
<p>The function is available only if <code>std::is_constructible&lt;value_type, Args...&gt;::value</code> is <code>true</code>.</p>
<p>Returns <code>false</code> if the ring is full or <code>true</code> otherwise. </p>

</div>
</div>
<a id="a1fe6e8db6d610ff34ea049ff7d6aa1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe6e8db6d610ff34ea049ff7d6aa1ae">&#9670;&nbsp;</a></span>enqueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = weak_ringbuffer::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html">cds::container::WeakRingBuffer</a>&lt; T, Traits &gt;::enqueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#af1167c5484a24b46471b3fd9cb162b69">value_type</a> const &amp;&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueues <code>val</code> value into the queue. </p>
<p>The new queue item is created by calling placement new in free cell. Returns <code>true</code> if success, <code>false</code> if the ring is full. </p>

</div>
</div>
<a id="aac8cccf098ab10638a020645b1c2e08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8cccf098ab10638a020645b1c2e08d">&#9670;&nbsp;</a></span>enqueue_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Traits  = weak_ringbuffer::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html">cds::container::WeakRingBuffer</a>&lt; T, Traits &gt;::enqueue_with </td>
          <td>(</td>
          <td class="paramtype">Func&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueues data to the ring using a functor. </p>
<p><code>Func</code> is a functor called to copy a value to the ring element. The functor <code>f</code> takes one argument - a reference to a empty cell of type <a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#af1167c5484a24b46471b3fd9cb162b69">value_type</a> : </p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_weak_ring_buffer.html">cds::container::WeakRingBuffer&lt; Foo &gt;</a> myRing;</div><div class="line">Bar bar;</div><div class="line">myRing.<a class="code" href="classcds_1_1container_1_1_weak_ring_buffer.html#aac8cccf098ab10638a020645b1c2e08d">enqueue_with</a>( [&amp;bar]( Foo&amp; dest ) { dest = std::move(bar); } );</div></div><!-- fragment --> 
</div>
</div>
<a id="afea0702fa72b4ee723f9f78f56de1372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea0702fa72b4ee723f9f78f56de1372">&#9670;&nbsp;</a></span>front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = weak_ringbuffer::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#af1167c5484a24b46471b3fd9cb162b69">value_type</a>* <a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html">cds::container::WeakRingBuffer</a>&lt; T, Traits &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets pointer to first element of ring buffer. </p>
<p>If the ring buffer is empty, returns <code>nullptr</code> </p>
<p>The function is thread-safe since there is only one consumer. Recall, <code><a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html" title="Single-producer single-consumer ring buffer. ">WeakRingBuffer</a></code> is single-producer/single consumer container. </p>

</div>
</div>
<a id="a13333a0c045795ff612f05f865a3b98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13333a0c045795ff612f05f865a3b98b">&#9670;&nbsp;</a></span>pop() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = weak_ringbuffer::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename CopyFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html">cds::container::WeakRingBuffer</a>&lt; T, Traits &gt;::pop </td>
          <td>(</td>
          <td class="paramtype">Q *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CopyFunc&#160;</td>
          <td class="paramname"><em>copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Batch pop <code>count</code> element from the ring buffer into <code>arr</code>. </p>
<p><code>CopyFunc</code> is a per-element copy functor: for each element of <code>arr</code> <code>copy( arr[i], source )</code> is called. The <code>CopyFunc</code> signature: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> copy_func( Q&amp; dest, <a class="code" href="classcds_1_1container_1_1_weak_ring_buffer.html#af1167c5484a24b46471b3fd9cb162b69">value_type</a>&amp; elemen );</div></div><!-- fragment --><p>Returns <code>true</code> if success or <code>false</code> if not enough space in the ring </p>

</div>
</div>
<a id="ab0d8ff8edfd188df6b14e4b1c59eda4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d8ff8edfd188df6b14e4b1c59eda4e">&#9670;&nbsp;</a></span>pop() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = weak_ringbuffer::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_assignable&lt;Q&amp;, <a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#af1167c5484a24b46471b3fd9cb162b69">value_type</a> const&amp;&gt;::value, bool&gt;::type <a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html">cds::container::WeakRingBuffer</a>&lt; T, Traits &gt;::pop </td>
          <td>(</td>
          <td class="paramtype">Q *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Batch pop - push array <code>arr</code> of size <code>count</code> with assignment as copy functor. </p>
<p>This function is equivalent for: </p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_weak_ring_buffer.html#a13333a0c045795ff612f05f865a3b98b">pop</a>( arr, count, []( Q&amp; dest, <a class="code" href="classcds_1_1container_1_1_weak_ring_buffer.html#af1167c5484a24b46471b3fd9cb162b69">value_type</a>&amp; src ) { dest = src; } );</div></div><!-- fragment --><p>The function is available only if <code>std::is_assignable&lt;Q&amp;, value_type const&amp;&gt;::value</code> is <code>true</code>.</p>
<p>Returns <code>true</code> if success or <code>false</code> if not enough space in the ring </p>

</div>
</div>
<a id="a90a249b769ffc63a5936e9a3f48905ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a249b769ffc63a5936e9a3f48905ab">&#9670;&nbsp;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = weak_ringbuffer::traits&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html">cds::container::WeakRingBuffer</a>&lt; T, Traits &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes front element of ring-buffer. </p>
<p>If the ring-buffer is empty, returns <code>false</code>. Otherwise, pops the first element from the ring. </p>

</div>
</div>
<a id="aad5bd7aab55417b4b873f355ea1bca96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5bd7aab55417b4b873f355ea1bca96">&#9670;&nbsp;</a></span>push() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = weak_ringbuffer::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename CopyFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html">cds::container::WeakRingBuffer</a>&lt; T, Traits &gt;::push </td>
          <td>(</td>
          <td class="paramtype">Q *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CopyFunc&#160;</td>
          <td class="paramname"><em>copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Batch push - push array <code>arr</code> of size <code>count</code>. </p>
<p><code>CopyFunc</code> is a per-element copy functor: for each element of <code>arr</code> <code>copy( dest, arr[i] )</code> is called. The <code>CopyFunc</code> signature: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> copy_func( <a class="code" href="classcds_1_1container_1_1_weak_ring_buffer.html#af1167c5484a24b46471b3fd9cb162b69">value_type</a>&amp; element, Q <span class="keyword">const</span>&amp; source );</div></div><!-- fragment --><p> Here <code>element</code> is uninitialized so you should construct it using placement new if needed; for example, if the element type is <code>str::string</code> and <code>Q</code> is <code>char const*</code>, <code>copy</code> functor can be: </p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_weak_ring_buffer.html">cds::container::WeakRingBuffer&lt;std::string&gt;</a> ringbuf;</div><div class="line"><span class="keywordtype">char</span> <span class="keyword">const</span>* arr[10];</div><div class="line">ringbuf.<a class="code" href="classcds_1_1container_1_1_weak_ring_buffer.html#aad5bd7aab55417b4b873f355ea1bca96">push</a>( arr, 10,</div><div class="line">    []( std::string&amp; element, <span class="keywordtype">char</span> <span class="keyword">const</span>* src ) {</div><div class="line">        <span class="keyword">new</span>( &amp;element ) std::string( src );</div><div class="line">    });</div></div><!-- fragment --><p> You may use move semantics if appropriate: </p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_weak_ring_buffer.html">cds::container::WeakRingBuffer&lt;std::string&gt;</a> ringbuf;</div><div class="line">std::string arr[10];</div><div class="line">ringbuf.<a class="code" href="classcds_1_1container_1_1_weak_ring_buffer.html#aad5bd7aab55417b4b873f355ea1bca96">push</a>( arr, 10,</div><div class="line">    []( std::string&amp; element, <a class="code" href="namespacestd.html">std</a>:<span class="keywordtype">string</span>&amp; src ) {</div><div class="line">        <span class="keyword">new</span>( &amp;element ) std::string( std::move( src ));</div><div class="line">    });</div></div><!-- fragment --><p>Returns <code>true</code> if success or <code>false</code> if not enough space in the ring </p>

</div>
</div>
<a id="aae3a59efe4975038abed8fcd6a0e408e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3a59efe4975038abed8fcd6a0e408e">&#9670;&nbsp;</a></span>push() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename Traits = weak_ringbuffer::traits&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_constructible&lt;<a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html#af1167c5484a24b46471b3fd9cb162b69">value_type</a>, Q&gt;::value, bool&gt;::type <a class="el" href="classcds_1_1container_1_1_weak_ring_buffer.html">cds::container::WeakRingBuffer</a>&lt; T, Traits &gt;::push </td>
          <td>(</td>
          <td class="paramtype">Q *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Batch push - push array <code>arr</code> of size <code>count</code> with assignment as copy functor. </p>
<p>This function is equivalent for: </p><div class="fragment"><div class="line"><a class="code" href="classcds_1_1container_1_1_weak_ring_buffer.html#aad5bd7aab55417b4b873f355ea1bca96">push</a>( arr, count, []( <a class="code" href="classcds_1_1container_1_1_weak_ring_buffer.html#af1167c5484a24b46471b3fd9cb162b69">value_type</a>&amp; dest, Q <span class="keyword">const</span>&amp; src ) { dest = src; } );</div></div><!-- fragment --><p>The function is available only if <code>std::is_constructible&lt;value_type, Q&gt;::value</code> is <code>true</code>.</p>
<p>Returns <code>true</code> if success or <code>false</code> if not enough space in the ring </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/container/weak_ringbuffer.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.3.1</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2017
  <br/>
  <i>Autogenerated Fri Sep 1 2017 08:47:11 by Doxygen 1.8.13</i>
</div>
</body>
</html>
