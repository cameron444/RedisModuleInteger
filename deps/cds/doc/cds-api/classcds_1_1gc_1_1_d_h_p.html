<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cds: cds::gc::DHP Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cds
   &#160;<span id="projectnumber">2.3.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classcds_1_1gc_1_1_d_h_p.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">cds::gc::DHP Class Reference<div class="ingroups"><a class="el" href="group__cds__garbage__collector.html">Garbage collectors</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Dynamic (adaptie) Hazard Pointer SMR.  
 <a href="classcds_1_1gc_1_1_d_h_p.html#details">More...</a></p>

<p><code>#include &lt;cds/gc/dhp.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1_d_h_p_1_1_guard.html">Guard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic Hazard Pointer guard.  <a href="classcds_1_1gc_1_1_d_h_p_1_1_guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1_d_h_p_1_1_guard_array.html">GuardArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of Dynamic Hazard Pointer guards.  <a href="classcds_1_1gc_1_1_d_h_p_1_1_guard_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1_d_h_p_1_1guarded__ptr.html">guarded_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded pointer.  <a href="classcds_1_1gc_1_1_d_h_p_1_1guarded__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad6f94dbe36ebd1a1a1fdd6457d95db25"><td class="memItemLeft" align="right" valign="top"><a id="ad6f94dbe36ebd1a1a1fdd6457d95db25"></a>
typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1_d_h_p.html#ad6f94dbe36ebd1a1a1fdd6457d95db25">guarded_pointer</a></td></tr>
<tr class="memdesc:ad6f94dbe36ebd1a1a1fdd6457d95db25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Native guarded pointer type. <br /></td></tr>
<tr class="separator:ad6f94dbe36ebd1a1a1fdd6457d95db25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3299cac0d2f7284ceeae5f6e4619b746"><td class="memTemplParams" colspan="2"><a id="a3299cac0d2f7284ceeae5f6e4619b746"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3299cac0d2f7284ceeae5f6e4619b746"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1_d_h_p.html#a3299cac0d2f7284ceeae5f6e4619b746">atomic_ref</a> = atomics::atomic&lt; T * &gt;</td></tr>
<tr class="memdesc:a3299cac0d2f7284ceeae5f6e4619b746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic reference. <br /></td></tr>
<tr class="separator:a3299cac0d2f7284ceeae5f6e4619b746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb8a07cdcb5f14cebed712e3b7a73de"><td class="memTemplParams" colspan="2"><a id="a6eb8a07cdcb5f14cebed712e3b7a73de"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6eb8a07cdcb5f14cebed712e3b7a73de"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1_d_h_p.html#a6eb8a07cdcb5f14cebed712e3b7a73de">atomic_type</a> = atomics::atomic&lt; T &gt;</td></tr>
<tr class="memdesc:a6eb8a07cdcb5f14cebed712e3b7a73de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic type. <br /></td></tr>
<tr class="separator:a6eb8a07cdcb5f14cebed712e3b7a73de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affeae2a85fb8e80b2e280086d9ef7f8e"><td class="memTemplParams" colspan="2"><a id="affeae2a85fb8e80b2e280086d9ef7f8e"></a>
template&lt;typename MarkedPtr &gt; </td></tr>
<tr class="memitem:affeae2a85fb8e80b2e280086d9ef7f8e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1_d_h_p.html#affeae2a85fb8e80b2e280086d9ef7f8e">atomic_marked_ptr</a> = atomics::atomic&lt; MarkedPtr &gt;</td></tr>
<tr class="memdesc:affeae2a85fb8e80b2e280086d9ef7f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Atomic marked pointer. <br /></td></tr>
<tr class="separator:affeae2a85fb8e80b2e280086d9ef7f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c85a7e0369b9cb15cd2925b46acbe2c"><td class="memItemLeft" align="right" valign="top"><a id="a9c85a7e0369b9cb15cd2925b46acbe2c"></a>
typedef <a class="el" href="structcds_1_1gc_1_1dhp_1_1stat.html">dhp::stat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1_d_h_p.html#a9c85a7e0369b9cb15cd2925b46acbe2c">stat</a></td></tr>
<tr class="memdesc:a9c85a7e0369b9cb15cd2925b46acbe2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal statistics. <br /></td></tr>
<tr class="separator:a9c85a7e0369b9cb15cd2925b46acbe2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afd5726364310a74bc0a9aefbc3facd26"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1_d_h_p.html#afd5726364310a74bc0a9aefbc3facd26">DHP</a> (size_t nInitialHazardPtrCount=16)</td></tr>
<tr class="memdesc:afd5726364310a74bc0a9aefbc3facd26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes DHP memory manager singleton.  <a href="#afd5726364310a74bc0a9aefbc3facd26">More...</a><br /></td></tr>
<tr class="separator:afd5726364310a74bc0a9aefbc3facd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d83af864d44020c228b8247c9cdc557"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1_d_h_p.html#a1d83af864d44020c228b8247c9cdc557">~DHP</a> ()</td></tr>
<tr class="memdesc:a1d83af864d44020c228b8247c9cdc557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys DHP memory manager.  <a href="#a1d83af864d44020c228b8247c9cdc557">More...</a><br /></td></tr>
<tr class="separator:a1d83af864d44020c228b8247c9cdc557"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a090f98b9405177ac282d154218aa5133"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1_d_h_p.html#a090f98b9405177ac282d154218aa5133">check_available_guards</a> (size_t nCountNeeded,)</td></tr>
<tr class="memdesc:a090f98b9405177ac282d154218aa5133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if count of hazard pointer is no less than <code>nCountNeeded</code>.  <a href="#a090f98b9405177ac282d154218aa5133">More...</a><br /></td></tr>
<tr class="separator:a090f98b9405177ac282d154218aa5133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addaff9c937beaa650a3134505736a145"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1_d_h_p.html#addaff9c937beaa650a3134505736a145">set_memory_allocator</a> (void *(*alloc_func)(size_t size), void(*free_func)(void *p))</td></tr>
<tr class="memdesc:addaff9c937beaa650a3134505736a145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set memory management functions.  <a href="#addaff9c937beaa650a3134505736a145">More...</a><br /></td></tr>
<tr class="separator:addaff9c937beaa650a3134505736a145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec005e48c74a32a050d143719ccab042"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec005e48c74a32a050d143719ccab042"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1_d_h_p.html#aec005e48c74a32a050d143719ccab042">retire</a> (T *p, void(*func)(void *))</td></tr>
<tr class="memdesc:aec005e48c74a32a050d143719ccab042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retire pointer <code>p</code> with function <code>pFunc</code>.  <a href="#aec005e48c74a32a050d143719ccab042">More...</a><br /></td></tr>
<tr class="separator:aec005e48c74a32a050d143719ccab042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599e8517bcf88bfb2f609007867e1512"><td class="memTemplParams" colspan="2">template&lt;class Disposer , typename T &gt; </td></tr>
<tr class="memitem:a599e8517bcf88bfb2f609007867e1512"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1_d_h_p.html#a599e8517bcf88bfb2f609007867e1512">retire</a> (T *p)</td></tr>
<tr class="memdesc:a599e8517bcf88bfb2f609007867e1512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retire pointer <code>p</code> with functor of type <code>Disposer</code>.  <a href="#a599e8517bcf88bfb2f609007867e1512">More...</a><br /></td></tr>
<tr class="separator:a599e8517bcf88bfb2f609007867e1512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0adf84336449c28e4e4e50b4ac8154f0"><td class="memItemLeft" align="right" valign="top"><a id="a0adf84336449c28e4e4e50b4ac8154f0"></a>
static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1_d_h_p.html#a0adf84336449c28e4e4e50b4ac8154f0">isUsed</a> ()</td></tr>
<tr class="memdesc:a0adf84336449c28e4e4e50b4ac8154f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if Dynamic Hazard Pointer GC is constructed and may be used. <br /></td></tr>
<tr class="separator:a0adf84336449c28e4e4e50b4ac8154f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d5865baa42a93fc72a7878723408ce2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1_d_h_p.html#a0d5865baa42a93fc72a7878723408ce2">scan</a> ()</td></tr>
<tr class="memdesc:a0d5865baa42a93fc72a7878723408ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forced GC cycle call for current thread.  <a href="#a0d5865baa42a93fc72a7878723408ce2">More...</a><br /></td></tr>
<tr class="separator:a0d5865baa42a93fc72a7878723408ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f74f3a7573638d7ca5161e45494f90b"><td class="memItemLeft" align="right" valign="top"><a id="a2f74f3a7573638d7ca5161e45494f90b"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1_d_h_p.html#a2f74f3a7573638d7ca5161e45494f90b">force_dispose</a> ()</td></tr>
<tr class="memdesc:a2f74f3a7573638d7ca5161e45494f90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synonym for <code><a class="el" href="classcds_1_1gc_1_1_d_h_p.html#a0d5865baa42a93fc72a7878723408ce2" title="Forced GC cycle call for current thread. ">scan()</a></code> <br /></td></tr>
<tr class="separator:a2f74f3a7573638d7ca5161e45494f90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf4f1c5e616c98fa64a35df04c1dd85"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1_d_h_p.html#abaf4f1c5e616c98fa64a35df04c1dd85">statistics</a> (<a class="el" href="classcds_1_1gc_1_1_d_h_p.html#a9c85a7e0369b9cb15cd2925b46acbe2c">stat</a> &amp;st)</td></tr>
<tr class="memdesc:abaf4f1c5e616c98fa64a35df04c1dd85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns internal statistics.  <a href="#abaf4f1c5e616c98fa64a35df04c1dd85">More...</a><br /></td></tr>
<tr class="separator:abaf4f1c5e616c98fa64a35df04c1dd85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02479b041a04c19a96fff50fc506f63"><td class="memItemLeft" align="right" valign="top">static CDS_EXPORT_API <a class="el" href="classcds_1_1gc_1_1_d_h_p.html#a9c85a7e0369b9cb15cd2925b46acbe2c">stat</a> const  &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcds_1_1gc_1_1_d_h_p.html#aa02479b041a04c19a96fff50fc506f63">postmortem_statistics</a> ()</td></tr>
<tr class="memdesc:aa02479b041a04c19a96fff50fc506f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns post-mortem statistics.  <a href="#aa02479b041a04c19a96fff50fc506f63">More...</a><br /></td></tr>
<tr class="separator:aa02479b041a04c19a96fff50fc506f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Dynamic (adaptie) Hazard Pointer SMR. </p>
<p>Implementation of Dynamic (adaptive) Hazard Pointer SMR</p>
<p>Sources:</p><ul>
<li>[2002] Maged M.Michael "Safe memory reclamation for dynamic lock-freeobjects using atomic reads and writes"</li>
<li>[2003] Maged M.Michael "Hazard Pointers: Safe memory reclamation for lock-free objects"</li>
<li>[2004] Andrei Alexandrescy, Maged Michael "Lock-free Data Structures with Hazard Pointers"</li>
</ul>
<p>DHP is an adaptive variant of classic <code><a class="el" href="classcds_1_1gc_1_1_h_p.html" title="Hazard Pointer SMR (Safe Memory Reclamation) ">cds::gc::HP</a></code>, see <a class="el" href="group__cds__garbage__collector.html">Compare HP implementation</a></p>
<dl class="section note"><dt>Note</dt><dd>Internally, DHP depends on free-list implementation. There are DCAS-based free-list <code><a class="el" href="classcds_1_1intrusive_1_1_tagged_free_list.html" title="Lock-free free list based on tagged pointers (required double-width CAS) ">cds::intrusive::TaggedFreeList</a></code> and more complicated CAS-based free-list <code><a class="el" href="classcds_1_1intrusive_1_1_free_list.html" title="Lock-free free list. ">cds::intrusive::FreeList</a></code>. For x86 architecture and GCC/clang, libcds selects appropriate free-list based on <code>-mcx16</code> compiler flag. You may manually disable DCAS support specifying <code>-DCDS_DISABLE_128BIT_ATOMIC</code> for 64bit build or <code>-DCDS_DISABLE_64BIT_ATOMIC</code> for 32bit build in compiler command line. All your projects and libcds MUST be compiled with the same flags - either with DCAS support or without it. For MS VC++ compiler DCAS is not supported.</dd></dl>
<p>See <a class="el" href="index.html#cds_how_to_use">How to use</a> section for details how to apply SMR. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afd5726364310a74bc0a9aefbc3facd26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5726364310a74bc0a9aefbc3facd26">&#9670;&nbsp;</a></span>DHP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cds::gc::DHP::DHP </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nInitialHazardPtrCount</em> = <code>16</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes DHP memory manager singleton. </p>
<p>Constructor creates and initializes DHP global object. DHP object should be created before using CDS data structure based on <code>cds::gc::DHP</code>. Usually, it is created in the beginning of <code>main()</code> function. After creating of global object you may use CDS data structures based on <code>cds::gc::DHP</code>.</p>
<p><code>nInitialThreadGuardCount</code> - initial count of guard allocated for each thread. When a thread is initialized the GC allocates local guard pool for the thread from a common guard pool. By perforce the local thread's guard pool is grown automatically from common pool. When the thread terminated its guard pool is backed to common GC's pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInitialHazardPtrCount</td><td>Initial number of hazard pointer per thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d83af864d44020c228b8247c9cdc557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d83af864d44020c228b8247c9cdc557">&#9670;&nbsp;</a></span>~DHP()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cds::gc::DHP::~DHP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys DHP memory manager. </p>
<p>The destructor destroys DHP global object. After calling of this function you may <b>NOT</b> use CDS data structures based on <code>cds::gc::DHP</code>. Usually, DHP object is destroyed at the end of your <code>main()</code>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a090f98b9405177ac282d154218aa5133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090f98b9405177ac282d154218aa5133">&#9670;&nbsp;</a></span>check_available_guards()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr bool cds::gc::DHP::check_available_guards </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nCountNeeded</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if count of hazard pointer is no less than <code>nCountNeeded</code>. </p>
<p>The function always returns <code>true</code> since the guard count is unlimited for <code>gc::DHP</code> garbage collector. </p>

</div>
</div>
<a id="aa02479b041a04c19a96fff50fc506f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02479b041a04c19a96fff50fc506f63">&#9670;&nbsp;</a></span>postmortem_statistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CDS_EXPORT_API <a class="el" href="classcds_1_1gc_1_1_d_h_p.html#a9c85a7e0369b9cb15cd2925b46acbe2c">stat</a> const&amp; cds::gc::DHP::postmortem_statistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns post-mortem statistics. </p>
<p>Post-mortem statistics is gathered in the <code>DHP</code> object destructor and can be accessible after destructing the global <code>DHP</code> object.</p>
<dl class="section note"><dt>Note</dt><dd>Internal statistics is available only if you compile <code>libcds</code> and your program with <code>-DCDS_ENABLE_HPSTAT</code>.</dd></dl>
<p>Usage: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <a class="code" href="namespacecds.html#ae14cc7bb67e75ea6ed18a82f3380d2c0">cds::Initialize</a>();</div><div class="line">    {</div><div class="line">        <span class="comment">// Initialize DHP SMR</span></div><div class="line">        cds::gc::DHP dhp;</div><div class="line"></div><div class="line">        <span class="comment">// deal with DHP-based data structured</span></div><div class="line">        <span class="comment">// ...</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// DHP object destroyed</span></div><div class="line">    <span class="comment">// Get total post-mortem statistics</span></div><div class="line">    <a class="code" href="structcds_1_1gc_1_1dhp_1_1stat.html">cds::gc::DHP::stat</a> <span class="keyword">const</span>&amp; st = <a class="code" href="classcds_1_1gc_1_1_d_h_p.html#aa02479b041a04c19a96fff50fc506f63">cds::gc::DHP::postmortem_statistics</a>();</div><div class="line"></div><div class="line">    printf( <span class="stringliteral">&quot;DHP statistics:\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;  thread count           = %llu\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;  guard allocated        = %llu\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;  guard freed            = %llu\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;  retired data count     = %llu\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;  free data count        = %llu\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;  scan() call count      = %llu\n&quot;</span></div><div class="line">        <span class="stringliteral">&quot;  help_scan() call count = %llu\n&quot;</span>,</div><div class="line">        st.<a class="code" href="structcds_1_1gc_1_1dhp_1_1stat.html#a5e49c933308355dac28c93fed8038cfb">thread_rec_count</a>,</div><div class="line">        st.<a class="code" href="structcds_1_1gc_1_1dhp_1_1stat.html#a67b79f01f3a4027703624745c40e9c52">guard_allocated</a>, st.<a class="code" href="structcds_1_1gc_1_1dhp_1_1stat.html#a29f36d62fa4c2d1f441188b613cd1944">guard_freed</a>,</div><div class="line">        st.<a class="code" href="structcds_1_1gc_1_1dhp_1_1stat.html#a21839e45101bd6ae8d68963f550a2b7b">retired_count</a>, st.<a class="code" href="structcds_1_1gc_1_1dhp_1_1stat.html#af9a44851f0c028f66064d0b44e8eaedf">free_count</a>,</div><div class="line">        st.<a class="code" href="structcds_1_1gc_1_1dhp_1_1stat.html#a1d0d2015438250beaf5d6602f36bd3f3">scan_count</a>, st.<a class="code" href="structcds_1_1gc_1_1dhp_1_1stat.html#a981160606e6dd2f13db97f88c6e74ad8">help_scan_count</a></div><div class="line">    );</div><div class="line"></div><div class="line">    <a class="code" href="namespacecds.html#a9ca275d587d2b0b11ded25220718a049">cds::Terminate</a>();</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="aec005e48c74a32a050d143719ccab042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec005e48c74a32a050d143719ccab042">&#9670;&nbsp;</a></span>retire() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cds::gc::DHP::retire </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retire pointer <code>p</code> with function <code>pFunc</code>. </p>
<p>The function places pointer <code>p</code> to array of pointers ready for removing. (so called retired pointer array). The pointer can be safely removed when no hazard pointer points to it. <code>func</code> is a disposer: when <code>p</code> can be safely removed, <code>func</code> is called. </p>

</div>
</div>
<a id="a599e8517bcf88bfb2f609007867e1512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599e8517bcf88bfb2f609007867e1512">&#9670;&nbsp;</a></span>retire() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Disposer , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cds::gc::DHP::retire </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retire pointer <code>p</code> with functor of type <code>Disposer</code>. </p>
<p>The function places pointer <code>p</code> to array of pointers ready for removing. (so called retired pointer array). The pointer can be safely removed when no hazard pointer points to it.</p>
<p>Deleting the pointer is an invocation of some object of type <code>Disposer</code>; the interface of <code>Disposer</code> is: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct </span>disposer {</div><div class="line">    <span class="keywordtype">void</span> operator()( T * p )    ;   <span class="comment">// disposing operator</span></div><div class="line">};</div></div><!-- fragment --><p> Since the functor call can happen at any time after <code><a class="el" href="classcds_1_1gc_1_1_d_h_p.html#aec005e48c74a32a050d143719ccab042" title="Retire pointer p with function pFunc. ">retire()</a></code> call, additional restrictions are imposed to <code>Disposer</code> type:</p><ul>
<li>it should be stateless functor</li>
<li>it should be default-constructible</li>
<li>the result of functor call with argument <code>p</code> should not depend on where the functor will be called.</li>
</ul>
<dl class="section user"><dt>Examples:</dt><dd>Operator <code>delete</code> functor: <div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">struct </span>disposer {</div><div class="line">    <span class="keywordtype">void</span> operator ()( T * p ) {</div><div class="line">        <span class="keyword">delete</span> p;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// How to call HP::retire method</span></div><div class="line"><span class="keywordtype">int</span> * p = <span class="keyword">new</span> int;</div><div class="line"></div><div class="line"><span class="comment">// ... use p in lock-free manner</span></div><div class="line"></div><div class="line">cds::gc::DHP::retire&lt;disposer&gt;( p ) ;   <span class="comment">// place p to retired pointer array of DHP SMR</span></div></div><!-- fragment --></dd></dl>
<p>Functor based on <code>std::allocator</code> : </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Alloc = std::allocator&lt;<span class="keywordtype">int</span>&gt; &gt;</div><div class="line"><span class="keyword">struct </span>disposer {</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line">    <span class="keywordtype">void</span> operator()( T * p ) {</div><div class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::templare rebind&lt;T&gt;::other alloc_t;</div><div class="line">        alloc_t a;</div><div class="line">        a.destroy( p );</div><div class="line">        a.deallocate( p, 1 );</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --> 
</div>
</div>
<a id="a0d5865baa42a93fc72a7878723408ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d5865baa42a93fc72a7878723408ce2">&#9670;&nbsp;</a></span>scan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cds::gc::DHP::scan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forced GC cycle call for current thread. </p>
<p>Usually, this function should not be called directly. </p>

</div>
</div>
<a id="addaff9c937beaa650a3134505736a145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addaff9c937beaa650a3134505736a145">&#9670;&nbsp;</a></span>set_memory_allocator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cds::gc::DHP::set_memory_allocator </td>
          <td>(</td>
          <td class="paramtype">void *(*)(size_t size)&#160;</td>
          <td class="paramname"><em>alloc_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *p)&#160;</td>
          <td class="paramname"><em>free_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set memory management functions. </p>
<dl class="section note"><dt>Note</dt><dd>This function may be called <b>BEFORE</b> creating an instance of Dynamic Hazard Pointer SMR</dd></dl>
<p>SMR object allocates some memory for thread-specific data and for creating SMR object. By default, a standard <code>new</code> and <code>delete</code> operators are used for this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alloc_func</td><td><code>malloc()</code> function </td></tr>
    <tr><td class="paramname">free_func</td><td><code>free()</code> function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abaf4f1c5e616c98fa64a35df04c1dd85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaf4f1c5e616c98fa64a35df04c1dd85">&#9670;&nbsp;</a></span>statistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cds::gc::DHP::statistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcds_1_1gc_1_1_d_h_p.html#a9c85a7e0369b9cb15cd2925b46acbe2c">stat</a> &amp;&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns internal statistics. </p>
<p>The function clears <code>st</code> before gathering statistics.</p>
<dl class="section note"><dt>Note</dt><dd>Internal statistics is available only if you compile <code>libcds</code> and your program with <code>-DCDS_ENABLE_HPSTAT</code>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cds/gc/dhp.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr/>
<div align="right">
  <b>cds</b> <b>2.3.1</b> 
  Developed by <i>Maxim Khizhinsky aka khizmax</i> 2007 - 2017
  <br/>
  <i>Autogenerated Fri Sep 1 2017 08:47:18 by Doxygen 1.8.13</i>
</div>
</body>
</html>
